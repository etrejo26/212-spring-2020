/**
 * @file CM_GraphicsView.cpp
 * @author Christopher McCooey
 * @date February 12, 2020
 * @brief This class represent the main graphical display port. This file is used to display the
 * circular linked list using radial geometry. Do not edit this file.
 */

#include "CM_GraphicsView.h"
#include "CM_ListEntry.h"
#ifdef USE_COMPLETED
	#include "DoublyLinkedList_completed.h"
#else
	#include "DoublyLinkedList.h"
#endif
#include "CM_DrawNode.h"
#include <QPainter>
#include <QMouseEvent>
#include <QKeyEvent>
#include <QPaintEvent>
#include <iostream>
#include <cmath>
#include <map>

#define MARGIN 48
#define INITIAL_PIECE_WIDTH 8
#define PIECE_HEIGHT 8
#define PIECE_GROWTH_FACTOR 3
#define GARBAGE_FLAG 0x1
#define NEXT_NODE_FLAG 0x2
#define ENTRY_HEIGHT 48

CM_GraphicsView::CM_GraphicsView(QWidget *parent) : QWidget(parent)
{
    m_list = new DoublyLinkedList("");
    m_entry = new CM_ListEntry(this);
    m_entry->setDLL(m_list);
    m_entry->setGeometry(2, 2, width() - 4, ENTRY_HEIGHT);
    m_mode = Mode_Normal;
    m_found_location = -1;
    m_random_string_index = 0;
    m_random_strings << "Hello!";
    m_random_strings << "My name is Chris." << "I am a TA for CSC 212." << "I am a graduate student." << "I made this GUI.";
    m_random_strings << "This GUI uses Qt and C++" << "This GUI should help you visualize circular doubly linked lists." << "You have used the string constructor a lot now." << "How many times are you going to test this button?" << "You likely tested this more than you need to.";
}
CM_GraphicsView::~CM_GraphicsView()
{
    delete m_list;
}

void CM_GraphicsView::keyFunction(QKeyEvent *ev)
{
    if (m_mode == Mode_Normal)
        m_entry->keyPressFunction(ev);
    else if (m_mode == Mode_Finished)
        setMode(Mode_Normal);
    else
    {
        QString str = ev->text();
        if (str.size() == 1)
        {
            int idx = -1;
            if (m_mode == Mode_Find_First)
                idx = m_list->findFirstOf(str.at(0).toLatin1());
            else if (m_mode == Mode_Find_Last)
                idx = m_list->findLastOf(str.at(0).toLatin1());
            m_found_location = idx;
            if (idx == -1)
                m_helper_text = QString("Character ") + str.at(0) + QString(" was not found");
            else
                m_helper_text = QString("Character ") + str.at(0) + QString(" found at index ") + QString::number(idx);
            m_helper_text.append("\nType any key to continue.");
            setMode(Mode_Finished); //go back to finished mode
            update();
        }
    }
}

void CM_GraphicsView::setMode(ModeEnum mode)
{
    if (m_mode != mode)
    {
        m_mode = mode;
        if (m_mode == Mode_Normal)
        {
            m_found_location = -1;
            if (m_entry->isHidden())
                m_entry->setHidden(false);
            m_helper_text.clear();
        }
        else if (m_mode != Mode_Normal && m_mode != Mode_Finished)
        {
            if (!m_entry->isHidden())
                m_entry->setHidden(true);
            m_helper_text = QString("Type a character on the keyboard to find ");
            if (m_mode == Mode_Find_First)
                m_helper_text.append("first.");
            else if (m_mode == Mode_Find_Last)
                m_helper_text.append("last.");
        }

        update();
    }
}


//keyboard events
void CM_GraphicsView::keyReleaseEvent(QKeyEvent *ev)
{
    m_entry->keyPressFunction(ev);
}
void CM_GraphicsView::resizeEvent(QResizeEvent *ev)
{
    ev->accept();
    m_entry->setGeometry(2, 2, width() - 4, ENTRY_HEIGHT);
}

//mouse events
void CM_GraphicsView::mousePressEvent(QMouseEvent* ev)
{
    if (ev->button() == Qt::LeftButton)
    {
        //m_ms->append(static_cast<int>(m_ms->getSize()), ev->y() / 100);
        update();
    }
}
void CM_GraphicsView::mouseMoveEvent(QMouseEvent* ev)
{
    QWidget::mouseMoveEvent(ev);
}
void CM_GraphicsView::mouseReleaseEvent(QMouseEvent* ev)
{
    QWidget::mouseReleaseEvent(ev);
}

//main draw function
void drawConnectionHelper(QPainter* painter, int x, int y, int other_x, int other_y, double angle_deg, double radius)
{
    QBrush brush;
    int x1, y1, x2, y2;
    double a1, a2;
    a1 = atan2(other_y - y, other_x - x) + angle_deg * M_PI / 180.0;
    a2 = atan2(y - other_y, x - other_x) - angle_deg * M_PI / 180.0;
    x1 = x + static_cast<int>(cos(a1) * radius);
    y1 = y + static_cast<int>(sin(a1) * radius);
    x2 = other_x + static_cast<int>(cos(a2) * radius);
    y2 = other_y + static_cast<int>(sin(a2) * radius);

    painter->drawLine(x1, y1, x2, y2);
    brush.setStyle(Qt::SolidPattern);
    brush.setColor(painter->pen().color());
    painter->setBrush(brush);
    painter->drawEllipse(QPoint(x2, y2), 4, 4);
}
void drawConnectionBad(QPainter* painter, int x, int y, double angle_deg, double radius, unsigned char flags)
{
    QBrush brush;
    QPen pen, old_pen;
    QString text;
    int x1, y1, x2, y2;
    double dx, dy, angle_radians;

    if (flags & NEXT_NODE_FLAG)
        angle_radians = angle_deg * M_PI / 180.0;
    else
        angle_radians = (angle_deg + 180.0) * M_PI / 180.0;
    dx = cos(angle_radians);
    dy = sin(angle_radians);

    x1 = x + static_cast<int>(dx * radius);
    y1 = y + static_cast<int>(dy * radius);
    x2 = x1 + static_cast<int>(dx * 100.0);
    y2 = y1 + static_cast<int>(dy * 100.0);

    old_pen = painter->pen();
    painter->drawLine(x1, y1, x2, y2);
    brush.setStyle(Qt::SolidPattern);
    brush.setColor(old_pen.color());
    painter->setBrush(brush);
    painter->drawEllipse(QPoint(x2, y2), 4, 4);

    //determine text
    if (flags & GARBAGE_FLAG)
        text = QString("Garbage Value");
    else
        text = QString("NULL");

    //draw text above
    pen.setColor(QColor(255, 0, 0));
    pen.setStyle(Qt::SolidLine);
    pen.setWidth(1);
    painter->setPen(pen);
    painter->drawText(x2 - 32, y2 - 5, text);

    //set pen back to what is was before
    painter->setPen(old_pen);
}

void CM_GraphicsView::paintEvent(QPaintEvent *ev)
{
    QWidget::paintEvent(ev);
    QPainter painter(this);
    QFont font("Verdana", 14, -1, false);
    QString status_text[2];
    QPen pen;
    QBrush brush;
    int num_elem = m_list->getSize(), circle_size = 48, x, y;

    //determine circle size
    if (m_list->getSize() >= 50)
        circle_size = 32;

    //setup the font
    painter.setFont(font);

    //draw the background
    pen.setStyle(Qt::NoPen);
    brush.setColor(QColor(70, 70, 70));
    brush.setStyle(Qt::SolidPattern);
    painter.setPen(pen);
    painter.setBrush(brush);
    painter.drawRect(rect());

    //draw the doubly linked list wheel
    num_elem = m_list->getSize();
    if (num_elem == 0)
    {
        pen.setStyle(Qt::SolidLine);
        pen.setColor(QColor(255, 255, 0));
        painter.setPen(pen);
        painter.drawText(rect().center(), QString("List is empty"));
    }
    else
    {
        int screen_min_bounds, diameter, i, cx, cy;
        double angle_incr, angle_iter, display_angle, radius;
        bool broken_size = false;
        Node* current, *head;
        QRect c_rect;

        //calculate the diameter of the circle we want
        screen_min_bounds = height() / 2;
        if (width() / 2 < screen_min_bounds)
            screen_min_bounds = width() / 2;
        diameter = screen_min_bounds - (circle_size / 2) - MARGIN;
        radius = (static_cast<double>(circle_size) / 2.0);

        //calculate the angle in radians in between each circle element
        angle_incr = M_PI * 2.0 / static_cast<double>(num_elem);
        angle_iter = 0.0;

        //determine the starting point of the doubly linked list pinwheel
        cx = width() / 2;
        cy = height() / 2;

        //get a associative map of locations
        std::map<Node*, CM_DrawNode> dictionary;
        head = m_list->firstNode();
        current = head;
        for (i = 0; i < num_elem; i++)
        {
            if (current == nullptr) //exit the loop if we found a null node in the list (should not happen)
            {
                broken_size = true;
                break;
            }
            //determine the x and y position we are going to draw the circle
            display_angle = angle_iter + (-M_PI / 2.0);
            x = cx + static_cast<int>(cos(display_angle) * diameter);
            y = cy + static_cast<int>(sin(display_angle) * diameter);
            dictionary.insert(std::pair<Node*, CM_DrawNode>(current, CM_DrawNode(x, y, i, display_angle)));
            current = current->next;

            //increase the angle
            angle_iter += angle_incr;
        }

        //display all the maps
        //for (i = 0; i < num_elem; i++)
        std::map<Node*, CM_DrawNode>::iterator iter = dictionary.begin();
        CM_DrawNode other;
        i = 0;
        while (iter != dictionary.end())
        {
            display_angle = angle_iter + (-M_PI / 2.0);

            //construct a rectangle to use as a bounding box for a circle around the (x, y) position calculated
            x = iter->second.cx;
            y = iter->second.cy;
            c_rect = QRect(x - circle_size / 2, y - circle_size / 2, circle_size, circle_size);

            //draw the chord
            pen.setStyle(Qt::SolidLine);
            pen.setColor(QColor(0, 0, 0));
            pen.setWidth(2);
            if (iter->first == head)
                brush.setColor(QColor(100, 255, 100));
            else if (m_found_location != -1 && iter->second.index == m_found_location)
                brush.setColor(QColor(255, 150, 0));
            else
                brush.setColor(QColor(255, 255, 255));
            brush.setStyle(Qt::SolidPattern);
            painter.setPen(pen);
            painter.setBrush(brush);
            painter.drawEllipse(c_rect);

            //draw text on top of that chord to represent the index
            pen.setColor(QColor(0, 0, 0));
            painter.setPen(pen);
            painter.drawText(c_rect.adjusted(c_rect.width() / 2 - 8, circle_size / 2 - 10, 0, 0), QString(iter->first->data));

            //go to the next display item
            ++iter;
        }

        //draw the pointer arrows
        iter = dictionary.begin();
        while (iter != dictionary.end())
        {
            x = iter->second.cx;
            y = iter->second.cy;

            //draw a line that points to the next node
            pen.setColor(QColor(255, 255, 0));
            pen.setWidth(2);
            painter.setPen(pen);
            if (iter->first->next == nullptr)
                drawConnectionBad(&painter, x, y, display_angle * 180.0 / M_PI, radius, NEXT_NODE_FLAG);
            else
            {
                if (dictionary.find(iter->first->next) == dictionary.end())
                    drawConnectionBad(&painter, x, y, display_angle * 180.0 / M_PI, radius, NEXT_NODE_FLAG & GARBAGE_FLAG);
                else
                {
                    other = dictionary.at(iter->first->next);
                    drawConnectionHelper(&painter, x, y, other.cx, other.cy, 10.0, radius);
                }
            }

            //draw a line that points to the previous node
            pen.setColor(QColor(0, 200, 0)); //dark green
            pen.setWidth(2);
            painter.setPen(pen);
            if (iter->first->previous == nullptr)
                drawConnectionBad(&painter, x, y, display_angle * 180.0 / M_PI, radius, 0x0);
            else
            {
                if (dictionary.find(iter->first->previous) == dictionary.end())
                    drawConnectionBad(&painter, x, y, display_angle * 180.0 / M_PI, radius, GARBAGE_FLAG);
                else
                {
                    other = dictionary.at(iter->first->previous);
                    drawConnectionHelper(&painter, x, y, other.cx, other.cy, 20.0, radius);
                }
            }

            //go to the next display item
            ++iter;
        }

        //if we encountered a broken size draw this in the top right corner
        if (broken_size)
        {
            pen.setStyle(Qt::SolidLine);
            pen.setColor(QColor(150, 20, 20));
            pen.setWidth(1);
            painter.setPen(pen);
            painter.drawText(4, 34, "ERROR: Size of list does not match the number of nodes");
        }
    }

    //draw the linked list information in the top right corner
    status_text[0] = QString("Number of Nodes: ") + QString::number(m_list->getSize());
    pen.setColor(QColor(255, 255, 255));
    pen.setStyle(Qt::SolidLine);
    pen.setWidth(1);
    painter.setPen(pen);
    x = 4;
    y = m_entry->y() + 4;
    if (!m_entry->isHidden())
        y += + m_entry->height();
    painter.drawText(QRect(x, y, 256, 20), status_text[0]);
    y += 20;

    //draw helper text if there is any
    if (m_helper_text.size() > 0)
    {
        QRect r(x, y, width() - 8, height() - y);
        QTextOption option;

        option.setWrapMode(QTextOption::WordWrap);
        pen.setColor(QColor(255, 50, 50));
        painter.setPen(pen);
        painter.drawText(r, m_helper_text, option);
    }

    //finish drawing (forgetting this causes horrible graphics problems on Linux operating systems)
    painter.end();
}

void CM_GraphicsView::clearSlot()
{
    m_list->clear();
    m_entry->updateStr();
}
void CM_GraphicsView::randomStringSlot()
{
    const QString& str = m_random_strings.at(m_random_string_index);
    DoublyLinkedList* old_list = m_list;

    m_list = new DoublyLinkedList(str.toStdString());
    m_entry->setDLL(m_list);
    m_entry->setIndex(m_list->getSize());
    m_entry->updateStr();

    delete old_list;

    m_random_string_index++;
    if (m_random_string_index >= m_random_strings.size())
        m_random_string_index = 0;
}
